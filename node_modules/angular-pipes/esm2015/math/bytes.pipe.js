import * as tslib_1 from "tslib";
var BytesPipe_1;
import { Pipe } from '@angular/core';
import { isNumberFinite, isPositive, isInteger, toDecimal } from '../utils/utils';
let BytesPipe = BytesPipe_1 = class BytesPipe {
    transform(input, decimal = 0, from = 'B', to) {
        if (!(isNumberFinite(input) &&
            isNumberFinite(decimal) &&
            isInteger(decimal) &&
            isPositive(decimal))) {
            return input;
        }
        let bytes = input;
        let unit = from;
        while (unit !== 'B') {
            bytes *= 1024;
            unit = BytesPipe_1.formats[unit].prev;
        }
        if (to) {
            const format = BytesPipe_1.formats[to];
            const result = toDecimal(BytesPipe_1.calculateResult(format, bytes), decimal);
            return BytesPipe_1.formatResult(result, to);
        }
        for (const key in BytesPipe_1.formats) {
            if (BytesPipe_1.formats.hasOwnProperty(key)) {
                const format = BytesPipe_1.formats[key];
                if (bytes < format.max) {
                    const result = toDecimal(BytesPipe_1.calculateResult(format, bytes), decimal);
                    return BytesPipe_1.formatResult(result, key);
                }
            }
        }
    }
    static formatResult(result, unit) {
        return `${result} ${unit}`;
    }
    static calculateResult(format, bytes) {
        const prev = format.prev ? BytesPipe_1.formats[format.prev] : undefined;
        return prev ? bytes / prev.max : bytes;
    }
};
BytesPipe.formats = {
    'B': { max: 1024 },
    'kB': { max: Math.pow(1024, 2), prev: 'B' },
    'KB': { max: Math.pow(1024, 2), prev: 'B' },
    'MB': { max: Math.pow(1024, 3), prev: 'kB' },
    'GB': { max: Math.pow(1024, 4), prev: 'MB' },
    'TB': { max: Number.MAX_SAFE_INTEGER, prev: 'GB' }
};
BytesPipe = BytesPipe_1 = tslib_1.__decorate([
    Pipe({
        name: 'bytes'
    })
], BytesPipe);
export { BytesPipe };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnl0ZXMucGlwZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL2FuZ3VsYXItcGlwZXMvIiwic291cmNlcyI6WyJtYXRoL2J5dGVzLnBpcGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSxPQUFPLEVBQUUsSUFBSSxFQUFpQixNQUFNLGVBQWUsQ0FBQztBQUNwRCxPQUFPLEVBQUUsY0FBYyxFQUFFLFVBQVUsRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFRbEYsSUFBYSxTQUFTLGlCQUF0QixNQUFhLFNBQVM7SUFZbEIsU0FBUyxDQUFDLEtBQVUsRUFBRSxVQUFrQixDQUFDLEVBQUUsT0FBaUIsR0FBRyxFQUFFLEVBQWE7UUFFMUUsSUFBSSxDQUFDLENBQUMsY0FBYyxDQUFDLEtBQUssQ0FBQztZQUNuQixjQUFjLENBQUMsT0FBTyxDQUFDO1lBQ3ZCLFNBQVMsQ0FBQyxPQUFPLENBQUM7WUFDbEIsVUFBVSxDQUFDLE9BQU8sQ0FBQyxDQUFDLEVBQUU7WUFDMUIsT0FBTyxLQUFLLENBQUM7U0FDaEI7UUFFRCxJQUFJLEtBQUssR0FBRyxLQUFLLENBQUM7UUFDbEIsSUFBSSxJQUFJLEdBQUcsSUFBSSxDQUFDO1FBQ2hCLE9BQU8sSUFBSSxLQUFLLEdBQUcsRUFBRTtZQUNqQixLQUFLLElBQUksSUFBSSxDQUFDO1lBQ2QsSUFBSSxHQUFHLFdBQVMsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSyxDQUFDO1NBQ3hDO1FBRUQsSUFBSSxFQUFFLEVBQUU7WUFDSixNQUFNLE1BQU0sR0FBRyxXQUFTLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1lBRXJDLE1BQU0sTUFBTSxHQUFHLFNBQVMsQ0FBQyxXQUFTLENBQUMsZUFBZSxDQUFDLE1BQU0sRUFBRSxLQUFLLENBQUMsRUFBRSxPQUFPLENBQUMsQ0FBQztZQUU1RSxPQUFPLFdBQVMsQ0FBQyxZQUFZLENBQUMsTUFBTSxFQUFFLEVBQUUsQ0FBQyxDQUFDO1NBQzdDO1FBRUQsS0FBSyxNQUFNLEdBQUcsSUFBSSxXQUFTLENBQUMsT0FBTyxFQUFFO1lBQ2pDLElBQUksV0FBUyxDQUFDLE9BQU8sQ0FBQyxjQUFjLENBQUMsR0FBRyxDQUFDLEVBQUU7Z0JBQ3ZDLE1BQU0sTUFBTSxHQUFHLFdBQVMsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUM7Z0JBQ3RDLElBQUksS0FBSyxHQUFHLE1BQU0sQ0FBQyxHQUFHLEVBQUU7b0JBRXBCLE1BQU0sTUFBTSxHQUFHLFNBQVMsQ0FBQyxXQUFTLENBQUMsZUFBZSxDQUFDLE1BQU0sRUFBRSxLQUFLLENBQUMsRUFBRSxPQUFPLENBQUMsQ0FBQztvQkFFNUUsT0FBTyxXQUFTLENBQUMsWUFBWSxDQUFDLE1BQU0sRUFBRSxHQUFHLENBQUMsQ0FBQztpQkFDOUM7YUFDSjtTQUNKO0lBQ0wsQ0FBQztJQUVELE1BQU0sQ0FBQyxZQUFZLENBQUMsTUFBYyxFQUFFLElBQVk7UUFDNUMsT0FBTyxHQUFHLE1BQU0sSUFBSSxJQUFJLEVBQUUsQ0FBQztJQUMvQixDQUFDO0lBRUQsTUFBTSxDQUFDLGVBQWUsQ0FBQyxNQUF3QyxFQUFFLEtBQWE7UUFDMUUsTUFBTSxJQUFJLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsV0FBUyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQztRQUN0RSxPQUFPLElBQUksQ0FBQyxDQUFDLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQztJQUMzQyxDQUFDO0NBQ0osQ0FBQTtBQXZEVSxpQkFBTyxHQUF3RDtJQUNsRSxHQUFHLEVBQUUsRUFBQyxHQUFHLEVBQUUsSUFBSSxFQUFDO0lBQ2hCLElBQUksRUFBRSxFQUFDLEdBQUcsRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksRUFBRSxDQUFDLENBQUMsRUFBRSxJQUFJLEVBQUUsR0FBRyxFQUFDO0lBQ3pDLElBQUksRUFBRSxFQUFDLEdBQUcsRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksRUFBRSxDQUFDLENBQUMsRUFBRSxJQUFJLEVBQUUsR0FBRyxFQUFDO0lBQ3pDLElBQUksRUFBRSxFQUFDLEdBQUcsRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksRUFBRSxDQUFDLENBQUMsRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFDO0lBQzFDLElBQUksRUFBRSxFQUFDLEdBQUcsRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksRUFBRSxDQUFDLENBQUMsRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFDO0lBQzFDLElBQUksRUFBRSxFQUFDLEdBQUcsRUFBRSxNQUFNLENBQUMsZ0JBQWdCLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBQztDQUNuRCxDQUFDO0FBVE8sU0FBUztJQUhyQixJQUFJLENBQUM7UUFDRixJQUFJLEVBQUUsT0FBTztLQUNoQixDQUFDO0dBQ1csU0FBUyxDQXlEckI7U0F6RFksU0FBUyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFBpcGUsIFBpcGVUcmFuc2Zvcm0gfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgaXNOdW1iZXJGaW5pdGUsIGlzUG9zaXRpdmUsIGlzSW50ZWdlciwgdG9EZWNpbWFsIH0gZnJvbSAnLi4vdXRpbHMvdXRpbHMnO1xyXG5cclxuZXhwb3J0IHR5cGUgQnl0ZVVuaXQgPSAnQicgfCAna0InIHwgJ0tCJyB8ICdNQicgfCAnR0InIHwgJ1RCJztcclxuXHJcblxyXG5AUGlwZSh7XHJcbiAgICBuYW1lOiAnYnl0ZXMnXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBCeXRlc1BpcGUgaW1wbGVtZW50cyBQaXBlVHJhbnNmb3JtIHtcclxuXHJcbiAgICBzdGF0aWMgZm9ybWF0czogeyBba2V5OiBzdHJpbmddOiB7IG1heDogbnVtYmVyLCBwcmV2PzogQnl0ZVVuaXQgfSB9ID0ge1xyXG4gICAgICAgICdCJzoge21heDogMTAyNH0sXHJcbiAgICAgICAgJ2tCJzoge21heDogTWF0aC5wb3coMTAyNCwgMiksIHByZXY6ICdCJ30sXHJcbiAgICAgICAgJ0tCJzoge21heDogTWF0aC5wb3coMTAyNCwgMiksIHByZXY6ICdCJ30sIC8vIEJhY2t3YXJkIGNvbXBhdGlibGVcclxuICAgICAgICAnTUInOiB7bWF4OiBNYXRoLnBvdygxMDI0LCAzKSwgcHJldjogJ2tCJ30sXHJcbiAgICAgICAgJ0dCJzoge21heDogTWF0aC5wb3coMTAyNCwgNCksIHByZXY6ICdNQid9LFxyXG4gICAgICAgICdUQic6IHttYXg6IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSLCBwcmV2OiAnR0InfVxyXG4gICAgfTtcclxuXHJcblxyXG4gICAgdHJhbnNmb3JtKGlucHV0OiBhbnksIGRlY2ltYWw6IG51bWJlciA9IDAsIGZyb206IEJ5dGVVbml0ID0gJ0InLCB0bz86IEJ5dGVVbml0KTogYW55IHtcclxuXHJcbiAgICAgICAgaWYgKCEoaXNOdW1iZXJGaW5pdGUoaW5wdXQpICYmXHJcbiAgICAgICAgICAgICAgICBpc051bWJlckZpbml0ZShkZWNpbWFsKSAmJlxyXG4gICAgICAgICAgICAgICAgaXNJbnRlZ2VyKGRlY2ltYWwpICYmXHJcbiAgICAgICAgICAgICAgICBpc1Bvc2l0aXZlKGRlY2ltYWwpKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gaW5wdXQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgYnl0ZXMgPSBpbnB1dDtcclxuICAgICAgICBsZXQgdW5pdCA9IGZyb207XHJcbiAgICAgICAgd2hpbGUgKHVuaXQgIT09ICdCJykge1xyXG4gICAgICAgICAgICBieXRlcyAqPSAxMDI0O1xyXG4gICAgICAgICAgICB1bml0ID0gQnl0ZXNQaXBlLmZvcm1hdHNbdW5pdF0ucHJldiE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodG8pIHtcclxuICAgICAgICAgICAgY29uc3QgZm9ybWF0ID0gQnl0ZXNQaXBlLmZvcm1hdHNbdG9dO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdG9EZWNpbWFsKEJ5dGVzUGlwZS5jYWxjdWxhdGVSZXN1bHQoZm9ybWF0LCBieXRlcyksIGRlY2ltYWwpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIEJ5dGVzUGlwZS5mb3JtYXRSZXN1bHQocmVzdWx0LCB0byk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBCeXRlc1BpcGUuZm9ybWF0cykge1xyXG4gICAgICAgICAgICBpZiAoQnl0ZXNQaXBlLmZvcm1hdHMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZm9ybWF0ID0gQnl0ZXNQaXBlLmZvcm1hdHNba2V5XTtcclxuICAgICAgICAgICAgICAgIGlmIChieXRlcyA8IGZvcm1hdC5tYXgpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdG9EZWNpbWFsKEJ5dGVzUGlwZS5jYWxjdWxhdGVSZXN1bHQoZm9ybWF0LCBieXRlcyksIGRlY2ltYWwpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQnl0ZXNQaXBlLmZvcm1hdFJlc3VsdChyZXN1bHQsIGtleSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIGZvcm1hdFJlc3VsdChyZXN1bHQ6IG51bWJlciwgdW5pdDogc3RyaW5nKTogc3RyaW5nIHtcclxuICAgICAgICByZXR1cm4gYCR7cmVzdWx0fSAke3VuaXR9YDtcclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgY2FsY3VsYXRlUmVzdWx0KGZvcm1hdDogeyBtYXg6IG51bWJlciwgcHJldj86IEJ5dGVVbml0IH0sIGJ5dGVzOiBudW1iZXIpIHtcclxuICAgICAgICBjb25zdCBwcmV2ID0gZm9ybWF0LnByZXYgPyBCeXRlc1BpcGUuZm9ybWF0c1tmb3JtYXQucHJldl0gOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgcmV0dXJuIHByZXYgPyBieXRlcyAvIHByZXYubWF4IDogYnl0ZXM7XHJcbiAgICB9XHJcbn1cclxuIl19